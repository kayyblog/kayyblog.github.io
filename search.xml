<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>堆的C语言表示</title>
    <url>/2019/10/31/%E5%A0%86%E7%9A%84C%E8%AF%AD%E8%A8%80%E8%A1%A8%E7%A4%BA/</url>
    <content><![CDATA[<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ElementType int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HNode</span> *<span class="title">Heap</span>;</span> <span class="comment">/* 堆的类型定义 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HNode</span> &#123;</span></span><br><span class="line">    ElementType *Data; <span class="comment">/* 存储元素的数组 */</span></span><br><span class="line">    <span class="keyword">int</span> Size;          <span class="comment">/* 堆中当前元素个数 */</span></span><br><span class="line">    <span class="keyword">int</span> Capacity;      <span class="comment">/* 堆的最大容量 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> Heap MaxHeap; <span class="comment">/* 最大堆 */</span></span><br><span class="line"><span class="keyword">typedef</span> Heap MinHeap; <span class="comment">/* 最小堆 */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXDATA 1000  <span class="comment">/* 该值应根据具体情况定义为大于堆中所有可能元素的值 */</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function">MaxHeap <span class="title">CreateHeap</span><span class="params">( <span class="keyword">int</span> MaxSize )</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 创建容量为MaxSize的空的最大堆 */</span></span><br><span class="line"> </span><br><span class="line">    MaxHeap H = (MaxHeap)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct HNode));</span><br><span class="line">    H-&gt;Data = (ElementType *)<span class="built_in">malloc</span>((MaxSize+<span class="number">1</span>)*<span class="keyword">sizeof</span>(ElementType));</span><br><span class="line">    <span class="comment">/* 因为data[0]会被定义成大于数组内仍任何一个元素所以要创建Maxsize+1大小*/</span></span><br><span class="line">    H-&gt;Size = <span class="number">0</span>;</span><br><span class="line">    H-&gt;Capacity = MaxSize;</span><br><span class="line">    H-&gt;Data[<span class="number">0</span>] = MAXDATA; <span class="comment">/* 定义"哨兵"为大于堆中所有可能元素的值*/</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> H;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsFull</span><span class="params">( MaxHeap H )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (H-&gt;Size == H-&gt;Capacity);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">( MaxHeap H, ElementType X )</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 将元素X插入最大堆H，其中H-&gt;Data[0]已经定义为哨兵 */</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> ( IsFull(H) ) &#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"最大堆已满"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    i = ++H-&gt;Size; <span class="comment">/* i指向插入后堆中的最后一个元素的位置 */</span></span><br><span class="line">    <span class="keyword">for</span> ( ; H-&gt;Data[i/<span class="number">2</span>] &lt; X; i/=<span class="number">2</span> )</span><br><span class="line">        H-&gt;Data[i] = H-&gt;Data[i/<span class="number">2</span>]; <span class="comment">/* 上滤X */</span></span><br><span class="line">    H-&gt;Data[i] = X; <span class="comment">/* 将X插入 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR -1 <span class="comment">/* 错误标识应根据具体情况定义为堆中不可能出现的元素值 */</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">( MaxHeap H )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (H-&gt;Size == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">ElementType <span class="title">DeleteMax</span><span class="params">( MaxHeap H )</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 从最大堆H中取出键值为最大的元素，并删除一个结点 */</span></span><br><span class="line">    <span class="keyword">int</span> Parent, Child;</span><br><span class="line">    ElementType MaxItem, X;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> ( IsEmpty(H) ) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"最大堆已为空"</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    MaxItem = H-&gt;Data[<span class="number">1</span>];                   <span class="comment">/* 取出根结点存放的最大值 */</span></span><br><span class="line">                                            <span class="comment">/* 用最大堆中最后一个元素从根结点开始向上过滤下层结点 */</span></span><br><span class="line">    X = H-&gt;Data[H-&gt;Size--];                 <span class="comment">/* 注意当前堆的规模要减小 */</span></span><br><span class="line">    <span class="keyword">for</span>( Parent=<span class="number">1</span>; Parent*<span class="number">2</span>&lt;=H-&gt;Size; Parent=Child ) &#123;</span><br><span class="line">        Child = Parent * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>( (Child!=H-&gt;Size) &amp;&amp; (H-&gt;Data[Child]&lt;H-&gt;Data[Child+<span class="number">1</span>]) )<span class="comment">/*并且Child不是最后一个结点*/</span></span><br><span class="line">            Child++;                        <span class="comment">/* Child指向左右子结点的较大者 */</span></span><br><span class="line">        <span class="keyword">if</span>( X &gt;= H-&gt;Data[Child] ) <span class="keyword">break</span>;    <span class="comment">/* 找到了合适位置 */</span></span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">/* 下滤X */</span></span><br><span class="line">            H-&gt;Data[Parent] = H-&gt;Data[Child];</span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;Data[Parent] = X;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> MaxItem;</span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/*----------- 建造最大堆 -----------*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PercDown</span><span class="params">( MaxHeap H, <span class="keyword">int</span> p )</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 下滤：将H中以H-&gt;Data[p]为根的子堆调整为最大堆 */</span></span><br><span class="line">    <span class="keyword">int</span> Parent, Child;</span><br><span class="line">    ElementType X;</span><br><span class="line"> </span><br><span class="line">    X = H-&gt;Data[p]; <span class="comment">/* 取出根结点存放的值 */</span></span><br><span class="line">    <span class="keyword">for</span>( Parent=p; Parent*<span class="number">2</span>&lt;=H-&gt;Size; Parent=Child ) &#123;</span><br><span class="line">        Child = Parent * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>( (Child!=H-&gt;Size) &amp;&amp; (H-&gt;Data[Child]&lt;H-&gt;Data[Child+<span class="number">1</span>]) )</span><br><span class="line">            Child++;  <span class="comment">/* Child指向左右子结点的较大者 */</span></span><br><span class="line">        <span class="keyword">if</span>( X &gt;= H-&gt;Data[Child] ) <span class="keyword">break</span>; <span class="comment">/* 找到了合适位置 */</span></span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">/* 下滤X */</span></span><br><span class="line">            H-&gt;Data[Parent] = H-&gt;Data[Child];</span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;Data[Parent] = X;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildHeap</span><span class="params">( MaxHeap H )</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 调整H-&gt;Data[]中的元素，使满足最大堆的有序性  */</span></span><br><span class="line">  <span class="comment">/* 这里假设所有H-&gt;Size个元素已经存在H-&gt;Data[]中 */</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 从最后一个结点的父节点开始，到根结点1 */</span></span><br><span class="line">    <span class="keyword">for</span>( i = H-&gt;Size/<span class="number">2</span>; i&gt;<span class="number">0</span>; i-- )</span><br><span class="line">        PercDown( H, i );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C语言堆代码自存</p>
<a id="more"></a>

<p>其实啥也没有了哦</p>
]]></content>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建博客的辛酸史</title>
    <url>/2019/10/30/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%BE%9B%E9%85%B8%E5%8F%B2/</url>
    <content><![CDATA[<p>好不容易搭建完成了</p>
<p>不知道为什么在coding上面搭建SSH无法通过。</p>
]]></content>
  </entry>
  <entry>
    <title>你好</title>
    <url>/2019/10/30/%E4%BD%A0%E5%A5%BD/</url>
    <content><![CDATA[<p>你好，这是第一个博客</p>
]]></content>
  </entry>
  <entry>
    <title>hey</title>
    <url>/2019/10/30/hey/</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
